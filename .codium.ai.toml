[tests]
framework = "Pytest"  # Testing framework to use
use_mocks = false  # A hint to the test generator about whether to use mocks or not
num_desired_tests = 1  # How many tests should be generated by default
plan_instructions= "Dont use mock. Test directly on endpoints on 127.0.0.0 and then perform cleanup . Cleanup shall be done with instructions to database not to endpoints.. Dont use self as arg. client = TestClient(app) is already initialized.."
reference_test = """
def test_register_event_with_required_parameters():
    try:
    # Create a new user
        user = {
            "username": "test_user",
            "email": "test_user@example.com",
            "password": "password123"
        }
        response = client.post("/users/register", json=user)
        assert response.status_code == 200
        assert "User created successfully" in response.json()["message"]

        # Get the user id
        user_id = response.json()["uid"]

        # Get the access token
        response = client.post("/token", data={"username": user["username"], "password": user["password"]})
        assert response.status_code == 200
        access_token = response.json()["access_token"]

        # Register a new event
        event = {
            "title": "Test Event",
            "description": "This is a test event",
            "location": "Test Location",
            "start_time": time.time(),
            "end_time": time.time(),
            "current_user": user_id,
            "tags": ["#art"],
            "public": False
        }
        headers = {"Authorization": f"Bearer {access_token}"}
        response = client.post("/events/register", params=event, headers=headers)
        assert response.status_code == 200
        assert "Event created successfully" in response.json()["message"]
    finally:
        users_table.truncate()
        event_table.truncate()

def test_retrieve_public_event_with_valid_event_id_and_current_user():
    # Create a user
    try:
        user_data = {
            "username": "test_user",
            "email": "test_user@example.com",
            "password": "password123"
        }
        response = client.post("/users/register", json=user_data)
        assert response.status_code == 200
        assert "User created successfully" in response.json()["message"]

        # Get the user id
        user_id = response.json()["uid"]

        # Get access token
        token_response = client.post("/token", data={"username": user_data["username"], "password": user_data["password"]})
        assert token_response.status_code == 200
        access_token = token_response.json()["access_token"]

        # Create a public event
        event_data = {
            "title": "Public Event",
            "public": True,
            "description": "Public event",
            "location": "Test"
        }

        event_response = client.post("/events/register", params=event_data, headers={"Authorization": f"Bearer {access_token}"})
        assert event_response.status_code == 200
        event_id = event_response.json()["id_event"]

        # Retrieve the public event
        get_event_response = client.get(f"/events/{event_id}", headers={"Authorization": f"Bearer {access_token}"})
        assert get_event_response.status_code == 200

        # Check the event details
        event = get_event_response.json()
        assert event["title"] == event_data["title"]
        assert event["id"] == event_id
        assert event["public"] == event_data["public"]

    finally:
        # Clean up
        users_table.truncate()
        event_table.truncate()

def test_returns_list_of_events_with_valid_query_parameters():
    # Create test events using the client

    try:
        user_data = {
            "username": "test_user",
            "email": "test_user@example.com",
            "password": "password123"
        }
        response = client.post("/users/register", json=user_data)
        assert response.status_code == 200
        assert "User created successfully" in response.json()["message"]

        # Get the user id
        user_id = response.json()["uid"]

        # Get access token
        token_response = client.post("/token", data={"username": user_data["username"], "password": user_data["password"]})
        assert token_response.status_code == 200
        access_token = token_response.json()["access_token"]

        event1 = client.post("/events/register", params={"title": "Event 1","location": "test", "description": "Description 1", "public": True}, headers={"Authorization": f"Bearer {access_token}"}).json()
        event2 = client.post("/events/register", params={"title": "Event 2" ,"location": "test","description": "Description 2", "public": False},headers={"Authorization": f"Bearer {access_token}"}).json()
        event3 = client.post("/events/register", params={"title": "Event 3","location": "test", "description": "Description 3", "public": True}, headers={"Authorization": f"Bearer {access_token}"}).json()


        # Call the get_events endpoint with valid query parameters
        response = client.get("/events", params={"public": True})
        assert response.status_code == 200

        # Check that the response contains a list of events
        events = response.json()
        assert isinstance(events, list)
        assert len(events) == 2

        # Check the details of each event
        assert events[0]["title"] == "Event 1"
        assert events[0]["description"] == "Description 1"
        assert events[0]["public"] == True

        assert events[1]["title"] == "Event 3"
        assert events[1]["description"] == "Description 3"
        assert events[1]["public"] == True


    finally:
        # Clean up
        users_table.truncate()
        event_table.truncate()

def test_update_event_status_to_public_when_user_is_organizer_or_admin():
    try:
        user_data = {
            "username": "test_user",
            "email": "test_user@example.com",
            "password": "password123"
        }
        response = client.post("/users/register", json=user_data)
        assert response.status_code == 200
        assert "User created successfully" in response.json()["message"]

        # Get the user id
        user_id = response.json()["uid"]

        user_data1 = {
            "username": "test_user1",
            "email": "test_user1@example.com",
            "password": "password123"
        }
        response = client.post("/users/register", json=user_data1)
        assert response.status_code == 200
        assert "User created successfully" in response.json()["message"]

        # Get the user id
        user1_id = response.json()["uid"]

        # Get access token
        token_response = client.post("/token", data={"username": user_data["username"], "password": user_data["password"]})
        assert token_response.status_code == 200
        access_token = token_response.json()["access_token"]

        event1 = client.post("/events/register", params={"title": "Event 1", "location": "test", "description": "Description 1", "public": True}, headers={"Authorization": f"Bearer {access_token}"}).json()

        response = client.put(f"/events/{event1['id_event']}/admin", params={"username": "test_user1"},headers={"Authorization": f"Bearer {access_token}"})

        assert response.status_code == 200
        assert "Admin added successfully to event" in response.json()["message"]

        token_response = client.post("/token", data={"username": user_data1["username"], "password": user_data1["password"]})
        assert token_response.status_code == 200
        access_token = token_response.json()["access_token"]

        # Call the change_event_status endpoint with public=True and token in authorization header
        response = client.post(f"/events/{event1['id_event']}/status", params={"public": False}, headers={"Authorization": f"Bearer {access_token}"})

        # Assert that the status code is 200
        assert response.status_code == 200

        # Assert that the message is "Status updated successfully"
        assert response.json()["message"] == "Status updated successfully"

        # Assert that the event's public status is True
        event = client.get(f"/events/{event1['id_event']}", headers={"Authorization": f"Bearer {access_token}"}).json()
        assert event["public"] == False

    finally:
        # Cleanup
        event_table.truncate()
        users_table.truncate()
"""
